\documentclass{homework}

\usepackage{homework}
\usepackage{pythontex}

\title{CPS740 - Lista 1}
\author{Pedro Maciel Xavier}
\register{116023847}

\begin{document}
	\maketitle
	
	\quest
	
	\subquest[Primeiro Algoritmo]
	
	\subsubquest[Algoritmo]
	
	\begin{algor}{Ordenação de Lista}
	seja L[n]
	
	def ordena(L[], n):
		seja m, k
		para i = n até 2:
			m <- L[i]
			k <- i
			// Busca o maior elemento da sub-lista
			para j = i-1 até 1:
				// Novo maior
				se L[j] > m:
					m <- L[j]
					k <- j
			// Troca maior pelo último da sub-lista
			L[i] <-> L[k]
		retorna L
	\end{algor}

	\subsubquest[Passo-a-passo]
	\begin{align*}
	L = &\left\{2,7,5,6,\mathbf{9},0,1,4,8,5,\mathbf{3}\right\} 1 \times 11 = 11\\
	&\left\{2,7,5,6,3,0,1,4,\mathbf{8},\mathbf{5},9\right\} 2 \times 10 = 20\\
	&\left\{2,\mathbf{7},5,6,3,0,1,4,\mathbf{5},8,9\right\} 3 \times  9 = 27\\
	&\left\{2,5,5,\mathbf{6},3,0,1,\mathbf{4},7,8,9\right\} 4 \times  8 = 32\\
	&\left\{2,5,\mathbf{5},4,3,0,\mathbf{1},6,7,8,9\right\} 5 \times  7 = 35\\
	&\left\{2,\mathbf{5},1,4,3,\mathbf{0},5,6,7,8,9\right\} 6 \times  6 = 36\\
	&\left\{2,0,1,\mathbf{4},\mathbf{3},5,5,6,7,8,9\right\} 7 \times  5 = 35\\
	&\left\{2,0,1,\mathbf{3},4,5,5,6,7,8,9\right\} 8 \times  4 = 32\\
	&\left\{\mathbf{2},0,\mathbf{1},3,4,5,5,6,7,8,9\right\} 9 \times  3 = 27\\
	&\left\{\mathbf{1},\mathbf{0},2,3,4,5,5,6,7,8,9\right\}10 \times  2 = 20\\
	&\left\{0,1,2,3,4,5,5,6,7,8,9\right\} \text{Total de $275$ passos}
	\end{align*}
	
	\newpage
	
	\subquest[Segundo Algoritmo]
	
	\subsubquest[Algoritmo]
	\begin{algor}{Ordenação de Lista}
	seja L[n]
	
	def ordena(L[], n):
		seja i <- 2
		enquanto i <= n:
			// Verifica inversão
			se L[i-1] > L[i]:
				// Resolve inversão
				L[i-1] <-> L[i]
				se i > 2:
					i <- i - 1
				senão:
					i <- i + 1
			senão:
				i <- i + 1
		retorna L
	\end{algor}

	\subsubquest[Passo-a-passo]
	\begin{multicols}{2}
	\begin{align*}
	L = &\left\{2,7,5,6,9,0,1,4,8,5,3\right\}\\
	&\left\{2,\mathbf{5},\mathbf{7},6,9,0,1,4,8,5,3\right\}2\\
	&\left\{2,5,\mathbf{6},\mathbf{7},9,0,1,4,8,5,3\right\}3\\
	&\left\{2,5,6,7,\mathbf{0},\mathbf{9},1,4,8,5,3\right\}4\\
	&\left\{2,5,6,\mathbf{0},\mathbf{7},9,1,4,8,5,3\right\}1\\
	&\left\{2,5,\mathbf{0},\mathbf{6},7,9,1,4,8,5,3\right\}1\\
	&\left\{2,\mathbf{0},\mathbf{5},6,7,9,1,4,8,5,3\right\}1\\
	&\left\{\mathbf{0},\mathbf{2},5,6,7,9,1,4,8,5,3\right\}1\\
	&\left\{0,2,5,6,7,\mathbf{1},\mathbf{9},4,8,5,3\right\}5\\
	&\left\{0,2,5,6,\mathbf{1},\mathbf{7},9,4,8,5,3\right\}1\\
	&\left\{0,2,5,\mathbf{1},\mathbf{6},7,9,4,8,5,3\right\}1\\
	&\left\{0,2,\mathbf{1},\mathbf{5},6,7,9,4,8,5,3\right\}1\\
	&\left\{0,\mathbf{1},\mathbf{2},5,6,7,9,4,8,5,3\right\}1\\
	&\left\{0,1,2,5,6,7,\mathbf{4},\mathbf{9},8,5,3\right\}7\\
	&\left\{0,1,2,5,6,\mathbf{4},\mathbf{7},9,8,5,3\right\}1\\
	&\left\{0,1,2,5,\mathbf{4},\mathbf{6},7,9,8,5,3\right\}1\\
	&\left\{0,1,2,\mathbf{4},\mathbf{5},6,7,9,8,5,3\right\}1\\
	&\left\{0,1,2,4,5,6,7,\mathbf{8},\mathbf{9},5,3\right\}6\\
	&\left\{0,1,2,4,5,6,7,8,\mathbf{5},\mathbf{9},3\right\}3\\
	&\left\{0,1,2,4,5,6,7,\mathbf{5},\mathbf{8},9,3\right\}1\\
	&\left\{0,1,2,4,5,6,\mathbf{5},\mathbf{7},8,9,3\right\}1\\
	&\left\{0,1,2,4,5,\mathbf{5},\mathbf{6},7,8,9,3\right\}1\\
	&\left\{0,1,2,4,5,5,6,7,8,\mathbf{3},\mathbf{9}\right\}6\\
	&\left\{0,1,2,4,5,5,6,7,\mathbf{3},\mathbf{8},9\right\}1\\
	&\left\{0,1,2,4,5,5,6,\mathbf{3},\mathbf{7},8,9\right\}1\\
	&\left\{0,1,2,4,5,5,\mathbf{3},\mathbf{6},7,8,9\right\}1\\
	&\left\{0,1,2,4,5,\mathbf{3},\mathbf{5},6,7,8,9\right\}1\\
	&\left\{0,1,2,4,\mathbf{3},\mathbf{5},5,6,7,8,9\right\}1\\
	&\left\{0,1,2,\mathbf{3},\mathbf{4},5,5,6,7,8,9\right\}1\\
	&\left\{0,1,2,3,4,5,5,6,7,8,9\right\} \text{Total de  $64$ passos}
	\end{align*}
	\end{multicols}
	
	%% 2
	\quest
	Seja $G = (V, E)$ um grafo com $m$ arestas e $n$ vértices.\\
	
	\subsubquest A \textbf{Matriz de Adjacências} $A^{n \times n}$ de $G$ é dada por:
		\[A_{i,j} = \begin{cases}
			1, \text{ se } (i, j) \in E\\
			0, \text{ caso contrário}
		\end{cases}\]
	Desta maneira a matriz terá suas $n^2$ entradas. Por isso, precisaremos de, no mínimo, $n^2$ \emph{bits} para representá-lo assim.\\
	
	\subsubquest A \textbf{Estrutura de Adjacências} $L$ de $G$ consiste em uma lista de tamanho $n$ contendo em cada nó $i$ um ponteiro para uma lista que contém os vértices adjacentes a $i$. Ou simplesmente:
		$$j \in L_i \iff (i, j) \in E$$
	Neste caso, a demanda por espaço não está diretamente relacionada ao número de vértices, mas sim, à quantidade de arestas. Grafos com poucas conexões podem ser representados de maneira eficiente com essa estrutura. Por outro lado, redes muito conexas tornam esta abordagem indesejável.\\
	\\
	Para cada aresta introduzida no grafo temos um custo de $2e$ \emph{bits}, onde $e$ representa o armazenamento de um nó $j$ em uma lista e depende da implementação. O custo dobrado vem da necessidade de armazenar cada aresta em duas listas distintas. Por fim, o custo total para armazenar o grafo $G$ desta maneira seria de $2e \times m + v \times n$, considerando $v$ o custo para armazenar $L$.\\
	
	\subsubquest Comparando as duas escolhas de representação, é vantajoso optar pela \textbf{Matriz de Adjacências} sempre que
		$$n^2 < 2e \times m + v \times n$$
	Mesmo assim, outros fatores devem ser levados em consideração, dependendo do tipo de operação que será realizada com mais frequência. Por exemplo, se queremos calcular o grau de cada vértice de um grafo, teremos maior eficiência se estivermos trabalhando com uma \textbf{Estrutura de Adjacências}. Se queremos simplesmente verificar se uma aresta arbitrária $(v, w)$ pertence ao grafo, seria melhor estar lidando com uma \textbf{Matriz de Adjacências}.
	%% 3
	\quest
	O Teorema 2.1\cite{jayme:18} diz que um grafo $G$ possui ciclo euleriano se e somente se o grau de cada um de seus vértices for par.\par
	
	\begin{algor}{Verificando a existência de um ciclo euleriano}
	seja G(V, E)
	
	def tem_ciclo_euleriano(G):
		seja V <- $v$(G) // Vértices de G
		para cada v em V:
			se grau(v) % 2 == 1: // grau ímpar
				retorna 0 // Falso
		retorna 1 // Verdadeiro
	\end{algor}
	A princípio, podemos perceber que o algoritmo demanda $n$ verificações de grau, uma para cada vértice. No entanto, a operação \code{grau(v)} tem custo variado, a depender da implementação. Em uma matriz de adjacências simples, para cada vértice temos que verificar $n$ entradas da matriz para contabilizar o grau. Em uma lista de adjacências, o custo pode ser um pouco menor a depender da densidade do grafo, mas ainda será $O(n^2)$. Uma estratégia para contornar este problema consiste em adotar uma estrutura de dados adicional com o papel de contabilizar o grau de cada vértice. Os valores são atualizados a cada inserção ou remoção de aresta. Isso aumenta o custo destas operações. No entanto, o cálculo do grau de um vértice se torna uma simples consulta, realizada em tempo constante $O(1)$. Isso garante a verificação da presença de um ciclo euleriano em tempo linear (amortizado) $O(n)$. Isso é feito para cada componente conexa do grafo.

	%% 4
	\quest
	O Teorema 2.2\cite{jayme:18} afirma que um grafo bipartido só possui ciclos de tamanho par.\par
	
	Podemos pensar no problema de bipartir o grafo como uma tarefa de coloração. Isto é, para um grafo $G(V_{1} \cup V_{2}, E)$, podemos dizer que os vértices de $V_{1}$ possuem uma determinada "cor" \textbf{\color{red} 1} e os de $V_{2}$ são "coloridos" com a "cor" \textbf{\color{blue} 2}.\par
	
	\begin{algor}{Verificando se um grafo é bipartido}
	seja G(V, E)
	
	def bipartido(G):
		seja V <- _v_(G) // Vértices de G
		para cada v em V: // Descolore os vértices
			v.cor <- nulo
		
		seja v em V       // Vértice qualquer de V
		seja G' <- G       // Cópia do grafo
		seja cor <- 0      // Cor inicial
		v.cor <- cor      // Colore o vértice
		seja Q <- _fila_({v}) // Uma fila contendo v
		enquanto !_vazio_(Q):
			v <- S.remover()
			// Inverte a cor
			cor <- !v.cor
			para cada w em _viz_(G', v):
				// Já foi colorido
				se w.cor == cor:
					continua
				// Falha ao colorir
				se w.cor == !cor:
					retorna 0
				// Colore o vértice
				se w.cor == nulo:
					w.cor <- cor
					// Coloca `w` no fim da fila
					Q.inserir(w)
			// Remove `v` de G'
			G' <- G' - v
		retorna 1
	\end{algor}
	Aqui, realizamos uma operação para cada vértice, assim como uma outra para cada aresta. A complexidade total desta busca em largura é $O(|V| + |E|)$ para cada componente conexa do grafo.
	
	%% 5
	\quest
	Sendo $G(V, E)$ um grafo bipartido, podemos escrever $G(V_{1} \cup V_{2}, E)$.\par
	\subsubquest
	O problema de encontrar um conjunto independente de tamanho $k$ em um gravo $G(V, E)$ pode ser entendido como achar uma clique de mesmo tamanho no grafo complementar $G(V, \overline{E})$, onde $\overline{E} = \{e \in V \times V: e \not\in E\}$. Dessa maneira, quando olhamos para o complemento de $G(V, E)$, vemos duas cliques se formarem entre os vértices de $V_{1}$ e $V_{2}$ respectivamente, já que não havia uma aresta sequer no interior destes conjuntos de vértices. Assim, sabendo que um gravo é bipartido, encontramos em tempo linear $O(m + n)$ uma 2-coloração para cada componente conexa. Em seguida, comparamos o valor desejado de $k$ com o tamanho dos conjuntos $V_{1}$ e $V_{2}$ em tempo constante $O(1)$.\par
	
	Considerando os diversos custos envolvidos, podemos afirmar que, para grafos bipartidos, somos capazes de resolver este problema em \textbf{Tempo Polinomial}.\par
	
	\begin{algor}{Subconjunto independente em grafo bipartido}
	seja G(V, E) // Grafo bipartido
	
	def tem_subconjunto_independente(G, k):
		// colore o grafo (Algoritmo 5)
		se bipartido(G):
			seja V <- _v_(G)
		senão:
			retorna "Erro: Jurastes ser bipartido!"
			
		seja V0 <- {v em V: v.cor == 0}
		seja V1 <- {v em V: v.cor == 1}
		
		se k <= |V0| ou k <= |V1|:
			retorna 1
		senão:
			retorna 0
	\end{algor}
	
	\newpage
	
	\subsubquest
	Um ciclo hamiltoniano deve passar por todos os vértices exatamente uma vez, retornando ao ponto de partida. Como um grafo bipartido só possui arestas ligando vértices de $V_{1}$ a vértices de $V_{2}$, podemos afirmar que para passar uma única vez por cada vértice é preciso que os dois conjuntos tenham o mesmo tamanho. Caso contrário, após $2 \cdot min(|V_{1}|, |V_{2}|)$ passos não teríamos mais vértices não-visitados em um dos conjuntos, ficando assim presos no maior deles. Esta condição é necessária, porém não suficiente. Isso pode nos ajudar a fazer uma verificação rápida nos casos em que essa condição não é atendida. Uma outra ideia é verificar a existência de vértices cujo grau é 1. Estes não podem fazer parte um ciclo. Ambas as verificações podem ser realizadas em tempo linear $O(m + n)$ e não alteram a complexidade final do algoritmo, que é de uma ordem superior.\par
	
	O algoritmo apresentado consiste inserir os vértices que fazem parte do caminho em uma pilha \code{P} conforme é feita a busca em profundidade. Os vértices a serem visitados são inseridos em uma outra pilha \code{S}, precedidos por um valor \type{nulo}, que sinaliza o retorno (desempilhamento do vértice no topo de \code{P}). Quando o caminho conta com todos os vértices do grafo, é feita uma verificação quanto a presença do primeiro vértice na vizinhança do último, para assim completar um ciclo.\par
	
	Para tratar da complexidade, lembramos que um Ciclo Hamiltoniano é uma sequência de vértices $\mathbb{H} = (v_1, v_2, \dots, v_n, v_{n+1}), v_{1} = v_{n+1}, v_{i} \in V, |V| = n$. Assim, podemos dizer que ao escolhermos um vértice arbitrário $v_{1}$ como ponto de partida nos deparamos com, no máximo, $n - 1$ opções de trajetórias em nosso primeiro passo. Um segundo passo dado em direção a $v_{2}$ nos trás $n-2$ novas possibilidades, visto que não planejamos em nenhum momento da caminhada retornar a um local transpassado anteriormente. Seguindo este raciocínio, podemos ter até mesmo $(n-1) \cdot (n-2) \cdot \cdots \cdot 2 \cdot 1 = (n-1)!$ caminhos diferentes. Em cada caminho que trilhamos, realizamos operações de tempo constante (inserções, remoções e comparações) sobre os $n$ vértices do grafo. Assim, podemos afirmar que este algoritmo possui complexidade assintótica $O(n!)$.\par
	
	Conclui-se que a complexidade de tempo é \textbf{Fatorial} e, portanto, de \textbf{Tempo Exponencial}, visto que $\exists n_0 \text{ tal que se } a > 1, a^n < n! ~ \forall n > n_0$. Portanto, este algoritmo \textbf{não é Polinomial}.
	
	\textbf{Nota:} O pseudo-código se encontra na próxima página.
	
	\newpage
	
	\begin{algor}{Ciclo Hamiltoniano}
	seja G(V, E)
	
	def tem_ciclo_hamiltoniano(G):
		// colore o grafo (Algoritmo 5)
		se bipartido(G):
			seja V <- _v_(G)
		senão:
			retorna "Erro: Jurastes ser bipartido!"
		// Verifica o tamanho das partições
		seja V0 <- {v em V: v.cor == 0}
		seja V1 <- {v em V: v.cor == 1}
		se |V0| != |V1|:
			retorna 0
		// Verifica o grau e descolore
		para cada v em V:
			se _grau_(G, v) <= 1:
				retorna 0
			senão:
				v.cor <- _nulo_
		
		seja r em V // Vértice qualquer de G
		seja P <- _pilha_() // Pilha vazia
		seja S <- _pilha_({_nulo_, r}) // Pilha
	
		enquanto |S| > 0:
			v <- S.remover()
			se v != _nulo_:
				P.inserir(v)
				se |P| == |V|:
					// Encontrou
					se r em _viz_(G, v):
						retorna 1
				senão:
					// Avante
					v.cor <- 1
					para cada w em _viz_(G, v):
						se w.cor == _nulo_:
							S.inserir(_nulo_)
							S.inserir(w)
					continua
			// Retroceder
			v <- P.remover()
			v.cor <- _nulo_
		retorna 0
		
	\end{algor}
	%% 6
	\quest
	\subsubquest Existe o caminho simples $(M, S)$.
	\subsubquest Não existe nenhum ciclo simples no digrafo.
	\subsubquest O grafo subjacente é conexo. No entanto, partindo de $P$ não alcançamos nem $N$, nem $O$ nem $Q$. Portanto, o digrafo é dito fracamente conexo.
	\subsubquest O grau de saída de $N$ é 4 e o de entrada é 1. Já o grau de saída de $R$ é 0 e o de entrada é 2.
	\subsubquest \\\\
		\textbf{Estrutura de Adjacências}:
		$$\{M: \{S\}, N:\{O, Q, R, S\}, O:\{M, N\}, P:\{M, P, R\}, Q:\{\}, R:\{\}, S:\{M\}\}$$
		
		\textbf{Matriz de Adjacências}:
		$$\left[\begin{matrix}
		0 & 0 & 0 & 0 & 0 & 0 & 1\\
		0 & 0 & 1 & 0 & 1 & 1 & 1\\
		1 & 1 & 0 & 0 & 0 & 0 & 0\\
		1 & 0 & 0 & 1 & 0 & 1 & 0\\
		0 & 0 & 0 & 0 & 0 & 0 & 0\\
		0 & 0 & 0 & 0 & 0 & 0 & 0\\
		1 & 0 & 0 & 0 & 0 & 0 & 0\\
		\end{matrix}\right]$$
	
	%% 7
	\quest
	\subsubquest A soma dos quadrados dos números de $1$ até $n$.
	
	%%\subsubquest São executadas sucessivas multiplicações seguidas de soma.
	
	\subsubquest Temos $n$ multiplicações e $n$ somas, totalizando $2n$ operações, ou seja, tempo linear $O(n)$.
	\subsubquest Existem algoritmos melhores. Demonstração:\\
	Temos que
	\begin{align*}
		x^3 - (x-1)^3 &= x^3 - (x^3 - 3x^2 + 3x - 1)\\
					  &= x^3 - x^3 + 3x^2 - 3x + 1\\
					  &= 3x^2 - 3x + 1
	\end{align*}
	Assim,
	\begin{align*}
		&\implies& (x-1)^3 - (x-2)^3 &= 3(x-1)^2 - 3(x-1) + 1\\
		&\implies& [x^3 - (x-1)^3] + [(x-1)^3 - (x-2)^3] &= [3x^2 - 3x + 1] + [3(x-1)^2 - 3(x-1) + 1]\\
		&\implies& x^3 - (x-2)^3 &= 3[x^2 + (x-1)^2] - 3[x + (x-1)] + 2\\
		& & &~\vdots\\
		&\implies& x^3 - (x-(n+1))^3 &= 3\sum_{i=1}^{n}(x-i)^2 - 3\sum_{i=1}^n(x-i) + (n+1)
	\end{align*}
	Escolhendo $x = 0$:
	\begin{align*}
	&\implies& -(-(n+1))^3 &= 3\sum_{i=1}^{n}(-i)^2 - 3\sum_{i=1}^n(-i) + (n+1)\\
	&\implies&     (n+1)^3 &= 3\sum_{i=1}^{n} i^2 + 3\sum_{i=1}^n i + (n+1)\\
	&\implies& \sum_{i=1}^{n} i^2 &= \frac{(n+1)^3 - (n+1)}{3} - \sum_{i=1}^n i\\
	&        &					  &= \frac{(n+1)^3 - (n+1)}{3} - \frac{n (n+1)}{2}
	\end{align*}
	Desta maneira, temos 3 somas, 3 multiplicações e 2 divisões, totalizando 8 operações, ou seja, tempo constante $O(1)$.
	
	\begin{thebibliography}{10}
		\bibitem{jayme:18} SZWARCFITER, Jayme Luiz, \textbf{Teoria Computacional de Grafos}, 1ª edição, Rio de Janeiro, 2018.
	\end{thebibliography}
\end{document}
